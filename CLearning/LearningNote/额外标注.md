## #define和const的区别

首先，#define和const都是定义作用

区别：
1.const 定义的常数是变量 也带类型， #define 定义的只是个常数 不带类型。
2.define只在预处理阶段起作用，它定义的宏在编译后消失了，不占用内存，但是const定义的常变量本质上是一种变量，有类型、占用存储单元。
3.define定义的对象没有数据类型，编译器只能机械地进行字符替换，没有类型安全检查，即会出现“边际问题”或者是“括号问题”。而const定义的是变量，有数据类型。
例如：

```c
#define N 2+3 //我们预想的N值是5，我们这样使用N
double a = N/2;  //我们预想的a的值是2.5，可实际上a的值是3.5
```

由于define只是进行机械的字符替换，所以上面的a结果是2+3/2=2+1.5=3.5

总结：
1.define不带类型，const带类型
2.define不占内存，const占内存
3.define只是简单的字符替换，可能会出现问题，不如const安全

## C 语言中全局变量、局部变量、静态全局变量、静态局部变量的区别

**从作用域看：**

1、**全局变量**具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。

2、**静态局部变量**具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

3、**局部变量**也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。

4、**静态全局变量**也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

**从分配内存空间看：**

1、全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间

2、全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

* 1)静态变量会被放在程序的静态数据存储区(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。
* 2)变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。

从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。

**Tips:**

* A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；
* B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；
* C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；
* D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带"内部存储器"功能的的函数)
* E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

## 二维数组传递给函数

列举 C 语言传递二维数组的方法。

方法1: 第一维的长度可以不指定，但必须指定第二维的长度：

```c
void print_a(int a[][5], int n, int m)
```

方法2: 指向一个有5个元素一维数组的指针：

```c
void print_b(int (*a)[5], int n, int m)
```

方法3: 利用数组是顺序存储的特性,通过降维来访问原数组!

```c
void print_c(int *a, int n, int m)
```

如果知道二维数组的长度，当然选择第一或者第二种方式，但是长度不确定时，只能传入数组大小来遍历元素啦。

```c
#include <stdio.h>
/*********************************
* 方法1: 第一维的长度可以不指定
*        但必须指定第二维的长度
*********************************/ 
void print_a(int a[][5], int n, int m){ 
    int i, j;
    for(i = 0; i < n; i++) {
        for(j = 0; j < m; j++) 
            printf("%d ", a[i][j]); 
        printf("\n"); 
    } 
} 

/***************************************** 
* 方法2: 指向一个有5个元素一维数组的指针
*****************************************/ 
void print_b(int (*a)[5], int n, int m) { 
    int i, j;
    for(i = 0; i < n; i++) { 
        for(j = 0; j < m; j++) 
            printf("%d ", a[i][j]);
        printf("\n"); 
    } 
}

/*********************************** 
* 方法3: 利用数组是顺序存储的特性, 
*       通过降维来访问原数组!
***********************************/ 
void print_c(int *a, int n, int m) { 
    int i, j; 
    for(i = 0; i < n; i++) { 
        for(j = 0; j < m; j++) 
            printf("%d ", *(a + i*m + j));
        printf("\n"); 
    } 
}
int main(void) 
{ 
    int a[5][5] = {{1, 2}, {3, 4, 5}, {6}, {7}, {0, 8}}; 

    printf("\n方法1:\n");   
    print_a(a, 5, 5); 

    printf("\n方法2:\n");   
    print_b(a, 5, 5);   

    printf("\n方法3:\n");   
    print_c(&a[0][0], 5, 5); 

//    getch(); 
    return 0; 
} 
```

## C **指向数组的指针**

您可以先跳过本章，等了解了 C 指针的概念之后，再来学习本章的内容。

如果您对 C 语言中指针的概念有所了解，那么就可以开始本章的学习。数组名是一个指向数组中第一个元素的常量指针。因此，在下面的声明中：

```c
double balance[50];
```

**balance** 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 **p** 赋值为 **balance** 的第一个元素的地址：

```c
double *p;
double balance[10];

p = balance;
```

使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。

一旦您把第一个元素的地址存储在 p 中，您就可以使用 *p、*(p+1)、*(p+2) 等来访问数组元素。下面的实例演示了上面讨论到的这些概念：

```c
#include <stdio.h>
 
int main ()
{
   /* 带有 5 个元素的整型数组 */
   double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
   double *p;
   int i;
 
   p = balance;
 
   /* 输出数组中每个元素的值 */
   printf( "使用指针的数组值\n");
   for ( i = 0; i < 5; i++ )
   {
       printf("*(p + %d) : %f\n",  i, *(p + i) );
   }
 
   printf( "使用 balance 作为地址的数组值\n");
   for ( i = 0; i < 5; i++ )
   {
       printf("*(balance + %d) : %f\n",  i, *(balance + i) );
   }
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
使用指针的数组值
*(p + 0) : 1000.000000
*(p + 1) : 2.000000
*(p + 2) : 3.400000
*(p + 3) : 17.000000
*(p + 4) : 50.000000
使用 balance 作为地址的数组值
*(balance + 0) : 1000.000000
*(balance + 1) : 2.000000
*(balance + 2) : 3.400000
*(balance + 3) : 17.000000
*(balance + 4) : 50.000000
```

在上面的实例中，p 是一个指向 double 型的指针，这意味着它可以存储一个 double 类型的变量。一旦我们有了 p 中的地址，***p** 将给出存储在 p 中相应地址的值，正如上面实例中所演示的。

## C 不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。

因为局部变量是存储在内存的栈区内，当函数调用结束后，局部变量所占的内存地址便被释放了，因此当其函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。

除非将其变量定义为 static 变量，static 变量的值存放在内存中的静态数据区，不会随着函数执行的结束而被清除，故能返回其地址。

## 字符串相关注意点

### 1.字符数组与字符指针

```c
char date[] = "June 14";
//它声明date是个字符数组
char *date = "June 14";
//它声明date是个指向字符串字面量的指针
```

上面两个声明中的date都可以作为字符串,但两者之间有差异.

* 在声明为数组时,就像任意数组元素一样,可以修改存储在date中的字符
  在声明为指针时,date指向字符串字面量,字符串字面量是不可以修改的,会导致一些编译器出现异常
* 在声明为数组时,date是数组名.
  在声明为变量时,date是变量,这个变量可以在程序执行期间指向其他字符串.

**如果需要可以修改的字符串,那么就要建立字符数组来存储字符串。这时声明指针变量是不够的**

下面的声明使编译器为指针变量分配了足够的内存空间:

```c
char *p;
```

可惜的是,它不为字符串分配空间(因为没有指明字符串的长度)。

在使用p作为字符串之前,必须把p指向字符数组。

一种方法是把p指向已经存在的字符串变量:

```c
char str[STR_LEN + 1], *p;

p = str;
```

现在p指向了str的第一个字符,所以可以把p作为字符串使用了.

**使用未初始化的指针变量作为字符串是非常严重的错误**

* 下面的例子试图创建字符串"abc"

```c
char *p;

p[0] = 'a';    /** WRONG **/
p[1] = 'b';    /** WRONG **/
p[2] = 'c';    /** WRONG **/
p[3] = '\0';   /** WRONG **/
```

因为p没有初始化,所以我们不知道它指向哪里。把字符a、b、c和\0写入p所指向的内存将会对程序产生无法预期的影响。程序可能没有错误继续运行，或者崩溃，或者行为异常。

### 2.字符串的读/写

#### 用**printf函数**和**puts函数**写字符串

1. 转换说明 **%s** 允许printf函数写字符串:

```c
char str[] = "Are we having fun yet?"

printf("Value of str is: %s\n",str);
```

输出是:`Value of str is:Are we having fun yet?`

* printf函数会逐个写字符串直到遇到空字符才停止。
* **如果空字符丢失,print函数会越过字符串的末尾继续写,直到最终在某个地方找到空字符为止.**

2. 转换说明 **%.ps**(p是要显示的字符数量)用来只显示字符串的一部分

```c
printf("%.6s\n",str);
```

会显示出:`Are we`

3. 转换说明 **%ms**会在大小为m的域内显示字符串

* 超过m个字符的字符串,会显示全部,而不是截断
* 少于m个字符的字符串,会在域内右对齐输出,在m前加一个减号可以强制左对齐
* m值和p值可以组合使用: %m.ps会使字符串前p个字符在大小为m的域内显示

4. **puts**函数

* **使用方式**:puts(str);
* 在写完字符串后,puts函数总会添加一个额外的换行符,因此显示会移至下一输出行的开始处

#### 用scanf函数和gets函数读字符串

1. 转换说明%s允许scanf函数读入字符串

```c
scanf("%s",str);
```

* 在scanf函数调用中,不需要在str前添加运算符&,因为str是数组名,编译器会自动把它当作指针来处理。
* 调用时,scanf函数会跳过空白字符,然后读入字符,并且把读入的字符存储到str中,直到遇到空白字符为止
* scanf函数始终会在字符串末尾存储一个空字符
* 用scanf函数读入字符串永远不会包含空白字符,因此scanf函数不会读入一整行输入,换行符、空格符、制表符都会导致scanf**停止读入**
* 为了每次读入一整行输入，可以使用gets函数

2. **gets**函数

* gets函数不会在开始读字符串之前跳过空白字符（scanf函数会跳过）
* gets函数会持续读入直到找到换行符才停止（scanf函数会在任意空白字符处停止）
* gets函数会忽略掉换行符，而不会把它存储到数组中，用空字符代替换行符

**例：**

```c
char sentence[SENT_LEN+1];

printf("Enter a sentence: \n");
scanf("%s",sentence);
```

假设在提示信息后输入信息：

`To C, or not to C: that is a question.`

scanf函数会把字符串“To”存储到sentence中。下一次scanf函数调用将从单词To后面的空格处继续读入这行。

现在假设用gets函数替换掉scanf函数：

`gets(sentence);`

当用户输入和先前相同的信息时，gets函数会把字符串

"To C, or not to C: that is a question."

存储到sentence中

* 在把字符读入数组时,scanf函数和gets函数都无法检测何时填满数组。因此，他们可能**越过数组边界**存储字符，导致程序行为异常。
* 通过用转换说明%ns代替%s可以使scanf函数更安全。
* 这里的数字n指出可以存储的最大字符数量。
* gets函数天生就是不安全的，fgets函数则是更安全的选择。

gets函数与puts函数运行速度更快。

### 3.strcmp（字符串比较）

strcmp（str1，str2）如何判断 **str1 小于 str2**

* s1与s2的前i个字符相同,但s1的第(i+1)个字符小于s2的第(i+1)个字符
  * 例如:"abc"小于"bcd",而"abc"小于"abd"
* s1的所有字符与s2的所有字符一致,但是s1比s2短
  * 例如:"abc"小于"abcd"

**ASCII码规律**:

* 大写字母(65~90) 小于 小写字母(97\~122)
* 数字(48~57) 小于 字母
* 空格(32) 小于 所有打印字符
